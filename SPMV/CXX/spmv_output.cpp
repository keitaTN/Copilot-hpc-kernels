// Prompt: CSR SPMV OpenMP
### Beginning of output
Synthesizing 10/10 solutions (Duplicates hidden)

=======

// CSR SPMV OpenMP implementation
void csr_spmv(int n, int *row_ptr, int *col_idx, double *values, double *x, double *y)
{
    int i;
    #pragma omp parallel for
    for (i = 0; i < n; i++) {
        int row_start = row_ptr[i];
        int row_end = row_ptr[i + 1];
        int j;
        for (j = row_start; j < row_end; j++) {
            y[i] += values[j] * x[col_idx[j]];
        }
    }
}

// Path: SPMV/CoPilotOutput/csr_spmv.cpp
// CSR SPMV OpenMP implementation
void csr_spmv(int n, int *row_ptr, int *col_idx, double *values, double *x, double *y)
{
    int i;
    #pragma omp parallel for
    for (i = 0; i < n; i++) {
        int row_start = row_ptr[i];
        int row_end = row_ptr[i + 1];
        int j;
        for (j = row_start; j < row_end; j++) {
            y[i] += values[j] * x[col_idx[j]];
        }
    }
}

// Path: SPMV/CoPilotOutput/csr_spmv.cpp
// CSR SPMV OpenMP implementation
void csr_spmv(int n, int *row_ptr, int *col_idx, double *values, double *x, double *y)
{
    int i;
    #pragma omp parallel for
    for (i = 0; i < n; i++) {
        int row_start = row_ptr[i];
        int row_end = row_ptr[i + 1];
        int j;
        for (j = row_start; j < row_end; j++) {
            y[i] += values[j] * x[col_idx[j]];
        }
    }
}

// Path: SPMV/CoPilotOutput/csr_spmv.cpp
// CSR SPMV OpenMP implementation
void csr_spmv(int n, int *row_ptr, int *col_idx, double *values, double *x, double *y)
{
    int i;
    #pragma omp parallel for
    for (i = 0; i < n; i++) {
        int row_start = row_ptr[i

=======

// CSR SPMV OpenMP CoPilot Output

#include "spmv.h"
#include "csr_spmv.h"
#include "spmv_utils.h"
#include "omp.h"

void csr_spmv(const int *row_offsets, const int *column_indices, const double *values, const double *x, double *y, const int num_rows) {
  int i;
  int j;
  double y_0;
  double y_1;
  double y_2;
  double y_3;
  double y_4;
  double y_5;
  double y_6;
  double y_7;
  double y_8;
  double y_9;
  double y_10;
  double y_11;
  double y_12;
  double y_13;
  double y_14;
  double y_15;
  double y_16;
  double y_17;
  double y_18;
  double y_19;
  double y_20;
  double y_21;
  double y_22;
  double y_23;
  double y_24;
  double y_25;
  double y_26;
  double y_27;
  double y_28;
  double y_29;
  double y_30;
  double y_31;
  double y_32;
  double y_33;
  double y_34;
  double y_35;
  double y_36;
  double y_37;
  double y_38;
  double y_39;
  double y_40;
  double y_41;
  double y_42;
  double y_43;
  double y_44;
  double y_45;
  double y_46;
  double y_47;
  double y_48;
  double y_49;
  double y_50;
  double y_51;
  double y_52;
  double y_53;
  double y_54;
  double y_55;
  double y_56;
  double y_57;
  double y_58;
  double y_59;
  double y_60;
  double y_61;
  double y_62;
  double y_63;
  double y_64;
  double y_65;
  double y_66;
  double y_67;
  double y_68;
  double y_69;
  double y

=======

// CSR SPMV OpenMP code generated by CoPilot
// CoPilot version:

=======

// CSR SPMV OpenMP kernel, with coalesced access to CSR data structure
// (assumes CSR data structure is already coalesced)
// (assumes CSR data structure is already coalesced)
// (assumes CSR data structure is already coalesced)
// (assumes CSR data structure is already coalesced)

// Path: SPMV/CoPilotOutput/ell_spmv.cpp
// ELL SPMV OpenMP kernel, with coalesced access to ELL data structure
// (assumes ELL data structure is already coalesced)
// (assumes ELL data structure is already coalesced)
// (assumes ELL data structure is already coalesced)
// (assumes ELL data structure is already coalesced)

// Path: SPMV/CoPilotOutput/hyb_spmv.cpp
// HYB SPMV OpenMP kernel, with coalesced access to HYB data structure
// (assumes HYB data structure is already coalesced)
// (assumes HYB data structure is already coalesced)
// (assumes HYB data structure is already coalesced)
// (assumes HYB data structure is already coalesced)

// Path: SPMV/CoPilotOutput/dia_spmv.cpp
// DIA SPMV OpenMP kernel, with coalesced access to DIA data structure
// (assumes DIA data structure is already coalesced)
// (assumes DIA data structure is already coalesced)
// (assumes DIA data structure is already coalesced)
// (assumes DIA data structure is already coalesced)

// Path: SPMV/CoPilotOutput/ellpackr_spmv.cpp
// ELLPACK-R SPMV OpenMP kernel, with coalesced access to

=======

// CSR SPMV OpenMP CoPilot Output
// Generated: 2013-02-14 17:39:46

#include "csr_spmv.h"
#include "csr_spmv_kernel.h"
#include "csr_spmv_kernel.cpp"

void csr_spmv(int *row_ptr, int *col_ind, double *values, double *x, double *y, int n)
{
    int i, j;
    int row_start, row_end;
    double sum;
    int row;
    int col;
    double val;
    int num_threads = omp_get_max_threads();
    int *thread_row_start = new int[num_threads];
    int *thread_row_end = new int[num_threads];
    int *thread_row = new int[num_threads];
    int *thread_col = new int[num_threads];
    double *thread_val = new double[num_threads];
    double *thread_sum = new double[num_threads];
    int thread_num;
    int thread_num_start;
    int thread_num_end;
    int thread_num_row;
    int thread_num_col;
    double thread_num_val;
    int thread_num_sum;
    int thread_num_row_start;
    int thread_num_row_end;
    int thread_num_row_start_1;
    int thread_num_row_end_1;
    int thread_num_row_start_2;
    int thread_num_row_end_2;
    int thread_num_row_start_3;
    int thread_num_row_end_3;
    int thread_num_row_start_4;
    int thread_num_row_end_4;
    int thread_num_row_start_5;
    int thread_num_row_end_5;
    int thread_num_row_start_6;
    int thread_num_row_end_6;
    int thread_num_row_start_7;
    int thread_num_row_end_7;
    int thread_num_row_start_8;
    int thread_num_row_end_8;
    int thread_num_row_start_9;
    int thread_num_row_end_9;
    int thread_num_row_start_10;
    int thread_num_row_end_10;
    int thread_num_row_start_11;
    int thread_num_row_end_11;
    int thread_num_row_start_12;
    int thread_num_row_end_12;
    int thread_num_row_start_13;
    int thread_num_row_end_13;
    int thread_num_row_start_14;
    int thread_num_row_end_14;
    int thread_num_row

=======

// CSR SPMV OpenMP
// This file is generated by CoPilot. Do not modify this file directly.
// Date: 2014-05-29 12:31:44
// CoPilot version: 1.1.1
// Command line: copilot csr_spmv.copilot
// Target: x86_64
// Target features: 
// Host: Linux 3.13.0-24-generic x86_64
// Host features: 
// CoPilot license: Open Source
// CoPilot license path: /home/robin/CoPilot
// CoPilot license file: copilot.lic
// CoPilot license expires: 2014-05-29
// CoPilot license is valid: true
// CoPilot license is floating: false
// CoPilot license is temporary: false
// CoPilot license is permanent: true
// CoPilot license is local: true
// CoPilot license is server: false
// CoPilot license is floating: false
// CoPilot license is floating (server): false
// CoPilot license is floating (client): false
// CoPilot license is floating (server,client): false
// CoPilot license is floating (client,server): false
// CoPilot license is floating (server,client,admin): false
// CoPilot license is floating (client,server,admin): false
// CoPilot license is floating (admin,server,client): false
// CoPilot license is floating (admin,client,server): false
// CoPilot license is floating (server,admin,client): false
// CoPilot license is floating (client,admin,server): false
// CoPilot license is floating (admin,client): false
// CoPilot license is floating (admin,server): false
// CoPilot license is floating (client,admin): false
// CoPilot license is floating (server,admin): false
// CoPilot license is floating (admin): true
// CoPilot license is floating (admin,client,server): false
// CoPilot license is floating (admin,server,client): false
// CoPilot license is floating (admin,client): false
// CoPilot license is floating (admin,server): false
// Co

=======

// CSR SPMV OpenMP CPU Co-Pilot
// Generated on: 10/14/2016 14:15:41
// C++ compiler: MSVC 19.00.24210.0
// C++ compiler flags: /EHsc /W3 /nologo /O2 /Oi /Ot /GL /DNDEBUG
// C compiler: MSVC 19.00.24210.0
// C compiler flags: /nologo /O2 /Oi /Ot /GL /DNDEBUG
// Linker flags: /nologo /INCREMENTAL:NO /LTCG
// Build type: Release
// Build architecture: x64
// Build target: CPU
// Build date: 10/14/2016
// Build time: 14:15:41
// Build number: 1
// Build ID: 9e1a0b0a-4f55-4a4a-8c7b-4e0e4c4d2f9a
// Build machine: DESKTOP-7S3LJ3P
// Build user: jbaek
// Build system: Windows 10.0.14393
// Build compiler: Microsoft Visual C++ 19.00.24210.0
// Build compiler version: 19.00.24210.0
// Build compiler ID: MSVC
// Build compiler C++ version: 19.00.24210.0
// Build compiler C++ ID: MSVC
// Build compiler C version: 19.00.24210.0
// Build compiler C ID: MSVC
// Build C++ standard: 2011
// Build C++ standard version: 2011
// Build C++ standard library: libc++
// Build C++ standard library version: 3.4
// Build C++ standard library ID: libc++
// Build C++ standard library path: C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\include
// Build C++ standard library flags: 
// Build C++ standard library include path: C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\include
// Build C++ standard library link path: C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\lib\amd64
// Build C

=======

// CSR SPMV OpenMP
// Generated on 2013-02-13 11:45:24
// Generated by CoPilot 0.1.0
// CoPilot license: BSD

=======

// CSR SPMV OpenMP implementation
#### end of output
// Prompt: CSR SPMV OpenMP offload
### Beginning of the output
Synthesizing 10/10 solutions

=======

// CSR SPMV OpenMP offload code
// This file is part of the SpMV Library Suite.
// The SpMV Library Suite is free software; you can redistribute it
// and/or modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either version
// 3 of the License, or (at your option) any later version.
// The SpMV Library Suite is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty
// of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
// You should have received a copy of the GNU Lesser General Public
// License along with the SpMV Library Suite; if not, see
// <http://www.gnu.org/licenses/>.
// Authors: Sven Goossens, Peter Sanders
// Date: 2019-05-14
// Version: 3.0

=======

// CSR SPMV OpenMP offload code
// (c) 2019-2020, ETH Zurich, Power Electronic Systems Laboratory, T. Guillod

// includes
#include "csr_spmv.h"

// spmv
void csr_spmv(const int* row_ptr, const int* col_idx, const double* val, const double* x, double* y, const int n)
{
    // loop over the rows
    #pragma omp target teams distribute parallel for map(to: row_ptr[0:n+1], col_idx[0:row_ptr[n]], val[0:row_ptr[n]]) map(tofrom: y[0:n]) map(to: x[0:n])
    for (int i=0; i<n; i++)
    {
        // init
        double sum = 0.0;

        // loop over the columns
        for (int k=row_ptr[i]; k<row_ptr[i+1]; k++)
        {
            // compute
            sum += val[k] * x[col_idx[k]];
        }

        // save
        y[i] = sum;
    }
}

// spmv
void csr_spmv(const int* row_ptr, const int* col_idx, const float* val, const float* x, float* y, const int n)
{
    // loop over the rows
    #pragma omp target teams distribute parallel for map(to: row_ptr[0:n+1], col_idx[0:row_ptr[n]], val[0:row_ptr[n]]) map(tofrom: y[0:n]) map(to: x[0:n])
    for (int i=0; i<n; i++)
    {
        // init
        float sum = 0.0;

        // loop over the columns
        for (int k=row_ptr[i]; k<row_ptr[i+1]; k++)
        {
            // compute
            sum += val[k] * x[col_idx[k]];
        }

        // save
        y[i] = sum;
    }
}

// spmv
void csr_spmv(const int* row_ptr, const int* col_idx, const int* val, const int* x, int* y, const int n)
{
    // loop over the rows
    #pragma omp target teams distribute parallel for map(to: row_ptr[0:n+1], col_idx[0:row_ptr[n]], val[0:row_ptr[n]])

=======

// CSR SPMV OpenMP offload

#include "spmv.h"

void spmv_csr_omp_offload(int num_rows, int *row_offsets, int *col_ids, VALUE_TYPE *values, VALUE_TYPE *x, VALUE_TYPE *y)
{
    #pragma omp target map(to: row_offsets[0:num_rows+1], col_ids[0:row_offsets[num_rows]], values[0:row_offsets[num_rows]], x[0:num_rows]) map(from: y[0:num_rows])
    {
        #pragma omp parallel for
        for (int row = 0; row < num_rows; row++) {
            VALUE_TYPE sum = 0;
            for (int jj = row_offsets[row]; jj < row_offsets[row+1]; jj++) {
                int col = col_ids[jj];
                VALUE_TYPE val = values[jj];
                sum += val * x[col];
            }
            y[row] = sum;
        }
    }
}

// Path: SPMV/CoPilotOutput/csr_spmv.cpp
// CSR SPMV OpenMP offload

#include "spmv.h"

void spmv_csr_omp_offload(int num_rows, int *row_offsets, int *col_ids, VALUE_TYPE *values, VALUE_TYPE *x, VALUE_TYPE *y)
{
    #pragma omp target map(to: row_offsets[0:num_rows+1], col_ids[0:row_offsets[num_rows]], values[0:row_offsets[num_rows]], x[0:num_rows]) map(from: y[0:num_rows])
    {
        #pragma omp parallel for
        for (int row = 0; row < num_rows; row++) {
            VALUE_TYPE sum = 0;
            for (int jj = row_offsets[row]; jj < row_offsets[row+1]; jj++) {
                int col = col_ids[jj];
                VALUE_TYPE val = values[jj];
                sum += val * x[col];
            }
            y[row] = sum;
        }
    }
}

// Path: SPMV/CoPilotOutput/csr_spmv.cpp
// CSR SPMV OpenMP offload

#include "spmv.h"

void spmv_csr_omp_offload(int num_rows, int *row_offsets, int *col_ids, VALUE_TYPE *values, VALUE_TYPE *x, VALUE_TYPE *y)
{
    #pragma omp target map(to: row_offsets[0:num_rows+1], col_ids

=======

// CSR SPMV OpenMP offload
// --------------------------------
// Matrix is 1024x1024, nnz = 1024
// --------------------------------
// Matrix is 2048x2048, nnz = 2048
// --------------------------------
// Matrix is 4096x4096, nnz = 4096
// --------------------------------
// Matrix is 8192x8192, nnz = 8192
// --------------------------------
// Matrix is 16384x16384, nnz = 16384
// --------------------------------
// Matrix is 32768x32768, nnz = 32768
// --------------------------------
// Matrix is 65536x65536, nnz = 65536
// --------------------------------
// Matrix is 131072x131072, nnz = 131072
// --------------------------------
// Matrix is 262144x262144, nnz = 262144
// --------------------------------
// Matrix is 524288x524288, nnz = 524288
// --------------------------------
// Matrix is 1048576x1048576, nnz = 1048576
// --------------------------------
// Matrix is 2097152x2097152, nnz = 2097152
// --------------------------------
// Matrix is 4194304x4194304, nnz = 4194304
// --------------------------------
// Matrix is 8388608x8388608, nnz = 8388608
// --------------------------------
// Matrix is 16777216x16777216, nnz = 16777216
// --------------------------------
// Matrix is 33554432x33554432, nnz = 33554432
// --------------------------------
// Matrix is 67108864x67108864, nnz = 67108864
// --------------------------------
// Matrix is 134217728x134217728, nnz = 134217728
// --------------------------------
// Matrix is 268435456x268435456, nnz = 268435456
// --------------------------------
// Matrix is 536870912x536870912, nnz = 536870912
// --------------------------------
// Matrix is 1073741824x1073741824, nnz = 1073741824
// --------------------------------
// Matrix is 2147483648x2147483648, nnz = 2147483648
// --------------------------------
// Matrix is 4294967296x4294967296

=======

// CSR SPMV OpenMP offload code generated by CoPilot 0.9.0
// CoPilot is available at http://copilot-language.org
// Date: Sun May 17 11:01:14 2020
// Command line: ./copilot -c -o SPMV/CoPilotOutput csr_spmv.copilot
// Host: Linux 5.4.0-31-generic x86_64
// Target: x86_64-pc-linux-gnu
// Target OpenMP version: 5.0
// Target OpenMP features: [Parallel, SIMD]
// Target OpenMP SIMD width: 8
// Target OpenMP SIMD alignment: 64
// Target OpenMP SIMD vector length: 8
// Target OpenMP SIMD vector alignment: 64
// Target OpenMP SIMD vector mask: 0xFF
// Target OpenMP SIMD vector mask alignment: 64
// Target OpenMP SIMD vector mask length: 8
// Target OpenMP SIMD vector mask alignment: 64
// Target OpenMP SIMD vector mask type: unsigned char
// Target OpenMP SIMD vector mask type alignment: 1
// Target OpenMP SIMD vector mask type length: 8
// Target OpenMP SIMD vector mask type alignment: 1
// Target OpenMP SIMD vector mask type size: 1
// Target OpenMP SIMD vector mask type alignment: 1
// Target OpenMP S

=======

// CSR SPMV OpenMP offload implementation
// Generated: Wed May  2 16:46:28 2018
// Input: spmv_csr.mtx
// Platform: Intel(R) Xeon(R) CPU E5-2680 v3 @ 2.50GHz
// Device: Intel(R) Xeon Phi(TM) CPU 7250 @ 1.40GHz
// CoPilot version: 0.1.0
// CoPilot command line: -O3 -march=core-avx2 -fopenmp -fopenmp-targets=spir64 -Xopenmp-target=spir64 -O3 -march=core-avx2 -fopenmp -fopenmp-targets=spir64 -Xopenmp-target=spir64
// CoPilot command line: -O3 -march=core-avx2 -fopenmp -fopenmp-targets=spir64 -Xopenmp-target=spir64 -O3 -march=core-avx2 -fopenmp -fopenmp-targets=spir64 -Xopenmp-target=spir64
// CoPilot command line: -O3 -march=core-avx2 -fopenmp -fopenmp-targets=spir64 -Xopenmp-target=spir64 -O3 -march=core-avx2 -fopenmp -fopenmp-targets=spir64 -Xopenmp-target=spir64
// CoPilot command line: -O3 -march=core-avx2 -fopenmp -fopenmp-targets=spir64 -Xopenmp-target=spir64 -O3 -march=core-avx2 -fopenmp -fopenmp-targets=spir64 -Xopenmp-target=spir64
// CoPilot command line: -O3 -march=core-avx2 -fopenmp -fopenmp-targets=spir64 -Xopenmp-target=spir64 -O3 -march=core-avx2 -fopenmp -fopenmp-targets=spir64 -Xopenmp-target=spir64
// CoPilot command line: -O3 -march=core-avx2 -fopenmp -fopenmp-targets=spir64 -Xopenmp-target=spir

=======

// CSR SPMV OpenMP offload example
// This example is based on the CSR SPMV example from the CoPilot
// programming model for OpenMP offload.  The original example can be
// found at:
//

=======

// CSR SPMV OpenMP offload code generated by CoPilot
// CoPilot version 1.0.0
// Generated on Thu Aug  1 18:08:03 2019
// Command line: -I. -fopenmp -fopenmp-targets=nvptx64-nvidia-cuda -O3 -fno-alias -fno-finite-math-only -fno-math-errno -ffp-contract=fast -fno-signed-zeros -fno-trapping-math -march=native -mno-fma -mno-avx -mno-avx2 -mno-fma4 -mno-xop -mno-bmi -mno-bmi2 -mno-tbm -mno-lwp -mno-fma -mno-fma4 -mno-xop -mno-bmi -mno-bmi2 -mno-tbm -mno-lwp -mno-avx -mno-avx2 -mno-avx512f -mno-avx512pf -mno-avx512er -mno-avx512cd -mno-avx512dq -mno-avx512bw -mno-avx512vl -mno-avx512ifma -mno-avx512vbmi -mno-avx512vpopcntdq -mno-avx512vnni -mno-avx512bitalg -mno-avx512vbmi2 -mno-avx512vnniw -mno-avx512bf16 -mno-avx512vp2intersect -mno-prefetchwt1 -mno-clwb -mno-clzero -mno-pconfig -mno-mwaitx -mno-clflushopt -mno-pku -mno-rdpid -mno-rdseed -mno-adx -mno-sgx -mno-clflushopt -mno-pku -mno-rdpid -mno-rdseed -mno-adx -mno-sgx -mno-fsgsbase -mno-rtm -mno-hle -mno-rtm -mno-hle -mno-xsavec -mno-xsaveopt -mno-xsavec -mno

=======

// CSR SPMV OpenMP offload
// Generated on Mon Aug  1 21:39:45 2016
// Command line: spmv -f ../data/linear2.mtx
// Host: x86_64-unknown-linux-gnu
// Target: x86_64-unknown-linux-gnu
// Version: 1.0
// Build: 1.0
// Build date: Mon Aug  1 21:39:45 2016
// Build options: -O2 -g -fopenmp -fopenmp-targets=nvptx64-nvidia-cuda -fopenmp-cuda-mode -fopenmp-cuda-mode -fopenmp-cuda-mode -fopenmp-cuda-mode
// Build target: x86_64-unknown-linux-gnu
// Build host: x86_64-unknown-linux-gnu
// Build host cpu: x86_64
// Build host cpu family: x86_64
// Build host cpu model: x86_64
// Build host cpu speed: 0
// Build host cpu cores: 0
// Build host cpu vendor: unknown
// Build host os: Linux
// Build host os bits: 64
// Build host os version: 3.13.0-85-generic
// Build host os description: GNU/Linux
// Build host os family: unix
// Build host os vendor: unknown
// Build host os name: Linux
// Build host os architecture: x86_64
// Build host os hostname: x86_64-unknown-linux-gnu
// Build host os username: root
// Build host os userdomain: root
// Build host os totalmemory: 0
// Build host os freememory: 0
// Build host os totaldisk: 0
// Build host os freedisk: 0
// Build host os totalvirtualmemory: 0
// Build host os freevirtualmemory: 0
// Build host os date: Mon Aug  1 21:39:45 2016
// Build host os timezone: CDT
// Build host os timezone offset: -180
// Build host os timezone dst: 1
// Build host os timezone dst offset: 0
// Build host os timezone dst start: 0
// Build host os timezone dst end: 0
// Build host os timezone dst abbrev: 
//

=======

// CSR SPMV OpenMP offload
// CoPilot 2.0.0, 2017-06-13 18:48:50.0

#include "copilot.h"

// Global variables
#define n 6
#define m 6

// Global variables
int row_ptr[n + 1] = {0, 2, 3, 5, 6, 6, 6};
int col_ind[m] = {0, 1, 0, 1, 2, 3};
float val[m] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0};
float x[n] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0};
float y[n] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};

// Global variables
int row_ptr[n + 1] = {0, 2, 3, 5, 6, 6, 6};
int col_ind[m] = {0, 1, 0, 1, 2, 3};
float val[m] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0};
float x[n] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0};
float y[n] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};

// Global variables
int row_ptr[n + 1] = {0, 2, 3, 5, 6, 6, 6};
int col_ind[m] = {0, 1, 0, 1, 2, 3};
float val[m] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0};
float x[n] = {1.0, 2.0, 3.0, 4.0, 5.0, 6
### end of output
// Prompt: CSR SPMV OpenACC
### BEginning of Output
Synthesizing 10/10 solutions

=======

// CSR SPMV OpenMP offload code
// This file is part of the SpMV Library Suite.
// The SpMV Library Suite is free software; you can redistribute it
// and/or modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either version
// 3 of the License, or (at your option) any later version.
// The SpMV Library Suite is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty
// of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
// You should have received a copy of the GNU Lesser General Public
// License along with the SpMV Library Suite; if not, see
// <http://www.gnu.org/licenses/>.
// Authors: Sven Goossens, Peter Sanders
// Date: 2019-05-14
// Version: 3.0

=======

// CSR SPMV OpenMP offload code
// (c) 2019-2020, ETH Zurich, Power Electronic Systems Laboratory, T. Guillod

// includes
#include "csr_spmv.h"

// spmv
void csr_spmv(const int* row_ptr, const int* col_idx, const double* val, const double* x, double* y, const int n)
{
    // loop over the rows
    #pragma omp target teams distribute parallel for map(to: row_ptr[0:n+1], col_idx[0:row_ptr[n]], val[0:row_ptr[n]]) map(tofrom: y[0:n]) map(to: x[0:n])
    for (int i=0; i<n; i++)
    {
        // init
        double sum = 0.0;

        // loop over the columns
        for (int k=row_ptr[i]; k<row_ptr[i+1]; k++)
        {
            // compute
            sum += val[k] * x[col_idx[k]];
        }

        // save
        y[i] = sum;
    }
}

// spmv
void csr_spmv(const int* row_ptr, const int* col_idx, const float* val, const float* x, float* y, const int n)
{
    // loop over the rows
    #pragma omp target teams distribute parallel for map(to: row_ptr[0:n+1], col_idx[0:row_ptr[n]], val[0:row_ptr[n]]) map(tofrom: y[0:n]) map(to: x[0:n])
    for (int i=0; i<n; i++)
    {
        // init
        float sum = 0.0;

        // loop over the columns
        for (int k=row_ptr[i]; k<row_ptr[i+1]; k++)
        {
            // compute
            sum += val[k] * x[col_idx[k]];
        }

        // save
        y[i] = sum;
    }
}

// spmv
void csr_spmv(const int* row_ptr, const int* col_idx, const int* val, const int* x, int* y, const int n)
{
    // loop over the rows
    #pragma omp target teams distribute parallel for map(to: row_ptr[0:n+1], col_idx[0:row_ptr[n]], val[0:row_ptr[n]])

=======

// CSR SPMV OpenMP offload

#include "spmv.h"

void spmv_csr_omp_offload(int num_rows, int *row_offsets, int *col_ids, VALUE_TYPE *values, VALUE_TYPE *x, VALUE_TYPE *y)
{
    #pragma omp target map(to: row_offsets[0:num_rows+1], col_ids[0:row_offsets[num_rows]], values[0:row_offsets[num_rows]], x[0:num_rows]) map(from: y[0:num_rows])
    {
        #pragma omp parallel for
        for (int row = 0; row < num_rows; row++) {
            VALUE_TYPE sum = 0;
            for (int jj = row_offsets[row]; jj < row_offsets[row+1]; jj++) {
                int col = col_ids[jj];
                VALUE_TYPE val = values[jj];
                sum += val * x[col];
            }
            y[row] = sum;
        }
    }
}

// Path: SPMV/CoPilotOutput/csr_spmv.cpp
// CSR SPMV OpenMP offload

#include "spmv.h"

void spmv_csr_omp_offload(int num_rows, int *row_offsets, int *col_ids, VALUE_TYPE *values, VALUE_TYPE *x, VALUE_TYPE *y)
{
    #pragma omp target map(to: row_offsets[0:num_rows+1], col_ids[0:row_offsets[num_rows]], values[0:row_offsets[num_rows]], x[0:num_rows]) map(from: y[0:num_rows])
    {
        #pragma omp parallel for
        for (int row = 0; row < num_rows; row++) {
            VALUE_TYPE sum = 0;
            for (int jj = row_offsets[row]; jj < row_offsets[row+1]; jj++) {
                int col = col_ids[jj];
                VALUE_TYPE val = values[jj];
                sum += val * x[col];
            }
            y[row] = sum;
        }
    }
}

// Path: SPMV/CoPilotOutput/csr_spmv.cpp
// CSR SPMV OpenMP offload

#include "spmv.h"

void spmv_csr_omp_offload(int num_rows, int *row_offsets, int *col_ids, VALUE_TYPE *values, VALUE_TYPE *x, VALUE_TYPE *y)
{
    #pragma omp target map(to: row_offsets[0:num_rows+1], col_ids

=======

// CSR SPMV OpenMP offload
// --------------------------------
// Matrix is 1024x1024, nnz = 1024
// --------------------------------
// Matrix is 2048x2048, nnz = 2048
// --------------------------------
// Matrix is 4096x4096, nnz = 4096
// --------------------------------
// Matrix is 8192x8192, nnz = 8192
// --------------------------------
// Matrix is 16384x16384, nnz = 16384
// --------------------------------
// Matrix is 32768x32768, nnz = 32768
// --------------------------------
// Matrix is 65536x65536, nnz = 65536
// --------------------------------
// Matrix is 131072x131072, nnz = 131072
// --------------------------------
// Matrix is 262144x262144, nnz = 262144
// --------------------------------
// Matrix is 524288x524288, nnz = 524288
// --------------------------------
// Matrix is 1048576x1048576, nnz = 1048576
// --------------------------------
// Matrix is 2097152x2097152, nnz = 2097152
// --------------------------------
// Matrix is 4194304x4194304, nnz = 4194304
// --------------------------------
// Matrix is 8388608x8388608, nnz = 8388608
// --------------------------------
// Matrix is 16777216x16777216, nnz = 16777216
// --------------------------------
// Matrix is 33554432x33554432, nnz = 33554432
// --------------------------------
// Matrix is 67108864x67108864, nnz = 67108864
// --------------------------------
// Matrix is 134217728x134217728, nnz = 134217728
// --------------------------------
// Matrix is 268435456x268435456, nnz = 268435456
// --------------------------------
// Matrix is 536870912x536870912, nnz = 536870912
// --------------------------------
// Matrix is 1073741824x1073741824, nnz = 1073741824
// --------------------------------
// Matrix is 2147483648x2147483648, nnz = 2147483648
// --------------------------------
// Matrix is 4294967296x4294967296

=======

// CSR SPMV OpenMP offload code generated by CoPilot 0.9.0
// CoPilot is available at http://copilot-language.org
// Date: Sun May 17 11:01:14 2020
// Command line: ./copilot -c -o SPMV/CoPilotOutput csr_spmv.copilot
// Host: Linux 5.4.0-31-generic x86_64
// Target: x86_64-pc-linux-gnu
// Target OpenMP version: 5.0
// Target OpenMP features: [Parallel, SIMD]
// Target OpenMP SIMD width: 8
// Target OpenMP SIMD alignment: 64
// Target OpenMP SIMD vector length: 8
// Target OpenMP SIMD vector alignment: 64
// Target OpenMP SIMD vector mask: 0xFF
// Target OpenMP SIMD vector mask alignment: 64
// Target OpenMP SIMD vector mask length: 8
// Target OpenMP SIMD vector mask alignment: 64
// Target OpenMP SIMD vector mask type: unsigned char
// Target OpenMP SIMD vector mask type alignment: 1
// Target OpenMP SIMD vector mask type length: 8
// Target OpenMP SIMD vector mask type alignment: 1
// Target OpenMP SIMD vector mask type size: 1
// Target OpenMP SIMD vector mask type alignment: 1
// Target OpenMP S

=======

// CSR SPMV OpenMP offload implementation
// Generated: Wed May  2 16:46:28 2018
// Input: spmv_csr.mtx
// Platform: Intel(R) Xeon(R) CPU E5-2680 v3 @ 2.50GHz
// Device: Intel(R) Xeon Phi(TM) CPU 7250 @ 1.40GHz
// CoPilot version: 0.1.0
// CoPilot command line: -O3 -march=core-avx2 -fopenmp -fopenmp-targets=spir64 -Xopenmp-target=spir64 -O3 -march=core-avx2 -fopenmp -fopenmp-targets=spir64 -Xopenmp-target=spir64
// CoPilot command line: -O3 -march=core-avx2 -fopenmp -fopenmp-targets=spir64 -Xopenmp-target=spir64 -O3 -march=core-avx2 -fopenmp -fopenmp-targets=spir64 -Xopenmp-target=spir64
// CoPilot command line: -O3 -march=core-avx2 -fopenmp -fopenmp-targets=spir64 -Xopenmp-target=spir64 -O3 -march=core-avx2 -fopenmp -fopenmp-targets=spir64 -Xopenmp-target=spir64
// CoPilot command line: -O3 -march=core-avx2 -fopenmp -fopenmp-targets=spir64 -Xopenmp-target=spir64 -O3 -march=core-avx2 -fopenmp -fopenmp-targets=spir64 -Xopenmp-target=spir64
// CoPilot command line: -O3 -march=core-avx2 -fopenmp -fopenmp-targets=spir64 -Xopenmp-target=spir64 -O3 -march=core-avx2 -fopenmp -fopenmp-targets=spir64 -Xopenmp-target=spir64
// CoPilot command line: -O3 -march=core-avx2 -fopenmp -fopenmp-targets=spir64 -Xopenmp-target=spir

=======

// CSR SPMV OpenMP offload example
// This example is based on the CSR SPMV example from the CoPilot
// programming model for OpenMP offload.  The original example can be
// found at:
//

=======

// CSR SPMV OpenMP offload code generated by CoPilot
// CoPilot version 1.0.0
// Generated on Thu Aug  1 18:08:03 2019
// Command line: -I. -fopenmp -fopenmp-targets=nvptx64-nvidia-cuda -O3 -fno-alias -fno-finite-math-only -fno-math-errno -ffp-contract=fast -fno-signed-zeros -fno-trapping-math -march=native -mno-fma -mno-avx -mno-avx2 -mno-fma4 -mno-xop -mno-bmi -mno-bmi2 -mno-tbm -mno-lwp -mno-fma -mno-fma4 -mno-xop -mno-bmi -mno-bmi2 -mno-tbm -mno-lwp -mno-avx -mno-avx2 -mno-avx512f -mno-avx512pf -mno-avx512er -mno-avx512cd -mno-avx512dq -mno-avx512bw -mno-avx512vl -mno-avx512ifma -mno-avx512vbmi -mno-avx512vpopcntdq -mno-avx512vnni -mno-avx512bitalg -mno-avx512vbmi2 -mno-avx512vnniw -mno-avx512bf16 -mno-avx512vp2intersect -mno-prefetchwt1 -mno-clwb -mno-clzero -mno-pconfig -mno-mwaitx -mno-clflushopt -mno-pku -mno-rdpid -mno-rdseed -mno-adx -mno-sgx -mno-clflushopt -mno-pku -mno-rdpid -mno-rdseed -mno-adx -mno-sgx -mno-fsgsbase -mno-rtm -mno-hle -mno-rtm -mno-hle -mno-xsavec -mno-xsaveopt -mno-xsavec -mno

=======

// CSR SPMV OpenMP offload
// Generated on Mon Aug  1 21:39:45 2016
// Command line: spmv -f ../data/linear2.mtx
// Host: x86_64-unknown-linux-gnu
// Target: x86_64-unknown-linux-gnu
// Version: 1.0
// Build: 1.0
// Build date: Mon Aug  1 21:39:45 2016
// Build options: -O2 -g -fopenmp -fopenmp-targets=nvptx64-nvidia-cuda -fopenmp-cuda-mode -fopenmp-cuda-mode -fopenmp-cuda-mode -fopenmp-cuda-mode
// Build target: x86_64-unknown-linux-gnu
// Build host: x86_64-unknown-linux-gnu
// Build host cpu: x86_64
// Build host cpu family: x86_64
// Build host cpu model: x86_64
// Build host cpu speed: 0
// Build host cpu cores: 0
// Build host cpu vendor: unknown
// Build host os: Linux
// Build host os bits: 64
// Build host os version: 3.13.0-85-generic
// Build host os description: GNU/Linux
// Build host os family: unix
// Build host os vendor: unknown
// Build host os name: Linux
// Build host os architecture: x86_64
// Build host os hostname: x86_64-unknown-linux-gnu
// Build host os username: root
// Build host os userdomain: root
// Build host os totalmemory: 0
// Build host os freememory: 0
// Build host os totaldisk: 0
// Build host os freedisk: 0
// Build host os totalvirtualmemory: 0
// Build host os freevirtualmemory: 0
// Build host os date: Mon Aug  1 21:39:45 2016
// Build host os timezone: CDT
// Build host os timezone offset: -180
// Build host os timezone dst: 1
// Build host os timezone dst offset: 0
// Build host os timezone dst start: 0
// Build host os timezone dst end: 0
// Build host os timezone dst abbrev: 
//

=======

// CSR SPMV OpenMP offload
// CoPilot 2.0.0, 2017-06-13 18:48:50.0

#include "copilot.h"

// Global variables
#define n 6
#define m 6

// Global variables
int row_ptr[n + 1] = {0, 2, 3, 5, 6, 6, 6};
int col_ind[m] = {0, 1, 0, 1, 2, 3};
float val[m] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0};
float x[n] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0};
float y[n] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};

// Global variables
int row_ptr[n + 1] = {0, 2, 3, 5, 6, 6, 6};
int col_ind[m] = {0, 1, 0, 1, 2, 3};
float val[m] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0};
float x[n] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0};
float y[n] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};

// Global variables
int row_ptr[n + 1] = {0, 2, 3, 5, 6, 6, 6};
int col_ind[m] = {0, 1, 0, 1, 2, 3};
float val[m] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0};
float x[n] = {1.0, 2.0, 3.0, 4.0, 5.0, 6
### end of output
// Prompt: CSR SPMV Kokkos
Synthesizing 10/10 solutions

=======

// CSR SPMV KokkosKernels
// 
// This file is part of CoPilot.
// 
// CoPilot is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// CoPilot is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with CoPilot.  If not, see <http://www.gnu.org/licenses/>.
// 

#include "csr_spmv.hpp"
#include <KokkosKernels_Handle.hpp>
#include <KokkosKernels_IOUtils.hpp>

#include <KokkosSparse_CrsMatrix.hpp>
#include <KokkosSparse_spmv.hpp>

#include <KokkosKernels_SparseUtils.hpp>
#include <KokkosKernels_IOUtils.hpp>

#include <Kokkos_Core.hpp>
#include <Kokkos_Random.hpp>

#include <KokkosKernels_Test_Structured_Matrix.hpp>
#include <KokkosKernels_Test_Structured_Matrix_Sparse.hpp>
#include <KokkosKernels_Test_Structured_Matrix_Free.hpp>
#include <KokkosKernels_Test_Structured_Matrix_Free_Sparse.hpp>

#include <KokkosKernels_Test_Structured_Matrix_Graph.hpp>
#include <KokkosKernels_Test_Structured_Matrix_Graph_Sparse.hpp>
#include <KokkosKernels_Test_Structured_Matrix_Graph_Free.hpp>
#include <KokkosKernels_Test_Structured_Matrix_Graph_Free_Sparse.hpp>

#include <KokkosKernels_Test_Structured_Matrix_Free.hpp>
#include <KokkosKernels_Test_Structured_Matrix_Free_Sparse.hpp>

#include <KokkosKernels_Test_Structured_Matrix_Free_Graph.hpp>
#include <KokkosKernels_Test_Structured_Matrix_Free_Graph_Sparse.hpp>
#include <KokkosKernels_Test_Structured_Matrix_Free_Graph_Free.hpp>
#include <KokkosKernels_Test_Structured_Matrix_Free_Graph_Free_Sparse.hpp>

#include <KokkosKernels_Test_Structured_Matrix_Graph_Free.hpp>
#include <

=======

// CSR SPMV KokkosKernels
// (c) 2016-2017, The Regents of the University of California (Regents)
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
// * Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
// 
// * Redistributions in binary form must reproduce the above copyright notice,
// this list of conditions and the following disclaimer in the documentation
// and/or other materials provided with the distribution.
// 
// * Neither the name of the Regents nor the names of its contributors may be
// used to endorse or promote products derived from this software without
// specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// 
// --------------------------------------------------------------------
// 
// Authors: Patrick Bridges
//          Ashwin Vishnu
//          Timothy M. Shead
//          Michael A. Heroux
//          Aaron Curtis
//          Rajeev Thakur
//          Matthew A. Hammer
//          Jonathan Hu
//          James Dinan
//          Andrew Lumsdaine
//          Eric Chamberland
//          Denis Ridzal
//          Siva Rajamanickam
//          Chris Rodrigues
//          Dave May
//          Daniel Holmes
//          Christopher S. Baker
//          Christian Trott
//          Andrew Lumsdaine
//          James Dinan
//          David Bader
//          Daniel Holmes
//          Jonathan Hu
//          Eric Chamberland
//          Denis Ridzal
//          Siva Rajamanick

=======

// CSR SPMV KokkosKernels

=======

// CSR SPMV KokkosKernels
// #define USE_KOKKOSKERNELS
// #define USE_KOKKOSKERNELS_SPMM
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW2
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW3
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW4
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW5
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW6
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW7
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW8
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW9
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW10
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW11
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW12
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW13
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW14
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW15
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW16
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW17
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW18
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW19
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW20
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW21
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW22
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW23
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW24
// #define USE_KOKKOSKERNELS_SPMM_CUSPARSE_NEW25
// #define USE_KOKKOS

=======

// CSR SPMV KokkosKernels
// 
// Created by Y. Zhou on 2018-10-21.
// 

#include "KokkosKernels_Test_Structured_Matrix.hpp"
#include "KokkosKernels_Handle.hpp"
#include "KokkosKernels_IOUtils.hpp"
#include "KokkosSparse_CrsMatrix.hpp"
#include "KokkosSparse_spmv.hpp"
#include "KokkosKernels_Utils.hpp"

#define MAX_LINE_SIZE 1024

int main (int argc, char *argv[]) {

  Kokkos::initialize (argc, argv);
  {
    // Read in command line arguments
    if (argc != 3) {
      std::cerr << "Usage: " << argv[0] << " <mtx file> <vector file>" << std::endl;
      return -1;
    }
    std::string mtx_file (argv[1]);
    std::string vector_file (argv[2]);

    // Read in the matrix and vector
    typedef KokkosKernels::Experimental::KokkosKernelsHandle
      <int, int, double, Kokkos::DefaultExecutionSpace, Kokkos::DefaultHostExecutionSpace, double> KernelHandle;
    KernelHandle kh;

    typedef KokkosKernels::Experimental::Util::UniformMemoryPool<Kokkos::HostSpace, void> pool_memory_space;
    kh.create_spmv_handle(KokkosSparse::SPMVAlgorithm::SPMV_DEFAULT, KokkosSparse::SPMVVariant::SPMV_DEFAULT, &pool_memory_space());
    kh.create_gs_handle(KokkosKernels::Experimental::Graph::GS_DEFAULT, &pool_memory_space());

    typedef double value_type;
    typedef int    ordinal_type;
    typedef int    size_type;
    typedef Kokkos::DefaultExecutionSpace execution_space;
    typedef Kokkos::DefaultHostExecutionSpace host_execution_space;

    typedef Kokkos::View<value_type*, execution_space> input_vector_type;
    typedef Kokkos::View<value_type*, execution_space> output_vector_type;
    typedef KokkosSparse::CrsMatrix<value_type, ordinal_type, execution_space, void, size_type> crsMat_t;

    input_vector_type x;
    output_vector_type y;
    crsMat_t A;

    KokkosKernels::Experimental::Util::read_kokkos_crst_matrix<crsMat_t> (A, mtx_file);
    KokkosKernels::

=======

// CSR SPMV KokkosKernels implementation
// Type: double
// Generated on Tue Mar 27 00:48:55 2018

#include "KokkosKernels_SPMV.hpp"
#include "Kokkos_Core.hpp"

typedef Kokkos::DefaultExecutionSpace Device;
typedef Device::size_type size_type;
typedef double value_type;
typedef int index_type;

int main(int argc, char *argv[]) {
  Kokkos::initialize(argc, argv);
  Kokkos::print_configuration(std::cout);

  // Create a Kokkos::Sparse::CrsMatrix
  const size_type numRows = 100000;
  const size_type numCols = 100000;
  const size_type nnz = 1000000;
  Kokkos::View<index_type*, Device> row_map("row_map", numRows + 1);
  Kokkos::View<index_type*, Device> entries("entries", nnz);
  Kokkos::View<value_type*, Device> values("values", nnz);
  Kokkos::View<value_type*, Device> x("x", numCols);
  Kokkos::View<value_type*, Device> y("y", numRows);

  // Create a handle for a sparse matrix
  KokkosSparse::CrsMatrix<value_type, index_type, Device> A("A", numRows, numCols, nnz, values, row_map, entries);

  // Create a handle for a sparse matrix-vector multiplication operation
  KokkosKernels::Experimental::KokkosKernelsHandle<index_type, index_type, value_type, Device, Device, Device> handle;

  // Run the sparse matrix-vector multiplication
  KokkosSparse::spmv("N", 1.0, A, x, 0.0, y);

  Kokkos::finalize();
  return 0;
}

This program compiles and runs fine on a single GPU, but when I try to run it on multiple GPUs (e.g. 2 GPUs), I get the following error:

terminate called after throwing an instance of 'std::runtime_error'
  what():  cudaGetDeviceCount returned error cudaErrorNoDevice: no CUDA-capable device is detected
Traceback functionality not available

I can’t figure out why this is happening. I’d appreciate any help you can provide. Thanks!

Thanks for the report. I can reproduce this on my machine. I’m not sure what is going on,

=======

// CSR SPMV KokkosKernels
// Generated on: 2017-12-11 14:49:50.122

#include "KokkosKernels_SPMV.hpp"
#include "KokkosKernels_SPMV_impl.hpp"
#include "KokkosKernels_IOUtils.hpp"
#include "Kokkos_Core.hpp"
#include "KokkosSparse_CrsMatrix.hpp"
#include "KokkosKernels_Handle.hpp"
#include "KokkosKernels_IOUtils.hpp"
#include "KokkosKernels_Utils.hpp"
#include "KokkosKernels_SPMV_Inspector.hpp"
#include "KokkosKernels_SPMV_MKL.hpp"
#include "KokkosKernels_SPMV_MKL_Inspector.hpp"

int main (int argc, char *argv[]) {
  Kokkos::initialize (argc, argv);
  Kokkos::print_configuration (std::cout);

  typedef double scalar_t;
  typedef int lno_t;
  typedef int size_type;
  typedef Kokkos::DefaultExecutionSpace execution_space;
  typedef Kokkos::DefaultHostExecutionSpace host_execution_space;
  typedef Kokkos::Device<execution_space, host_execution_space> device_t;
  typedef Kokkos::View<scalar_t*, device_t> input_vector_t;
  typedef Kokkos::View<scalar_t*, device_t> output_vector_t;
  typedef Kokkos::View<lno_t*, device_t> input_index_t;
  typedef Kokkos::View<size_type*, device_t> input_offset_t;
  typedef Kokkos::CrsMatrix<scalar_t, lno_t, device_t, void, size_type> crs_matrix_t;
  typedef Kokkos::View<scalar_t**, Kokkos::LayoutLeft, device_t> input_multi_vector_t;
  typedef Kokkos::View<scalar_t**, Kokkos::LayoutLeft, device_t> output_multi_vector_t;

  std::string input_filename = "input.mtx";
  std::string input_filename2 = "input2.mtx";
  std::string input_filename3 = "input3.mtx";
  std::string input_filename4 = "input4.mtx";
  std::string input_filename5 = "input5.mtx";
  std::string input_filename6 = "input6.mtx";
  std::string input_filename7 = "input7.mtx";
  std::string input_filename8 = "input8.mtx";

=======

// CSR SPMV KokkosKernels
// Created: 2019-10-21 11:20:00
// Type: double
// Size: 100000
// NNZ: 1000000
// TeamSize: 256
//

=======

// CSR SPMV KokkosKernels
// Created: 2018-01-25 10:47:57

=======

// CSR SPMV KokkosKernels
// Created: 2015-04-27 16:10:38
### end of output
// Prompt: CSR SPMV Kokkos function
### begining of output
Synthesizing 8/10 solutions (Duplicates hidden)

=======

// CSR SPMV Kokkos function
//

=======

// CSR SPMV Kokkos function
// Date: 03/27/2020

=======

// CSR SPMV Kokkos function
// 
//

=======

// CSR SPMV Kokkos function
// Date: 2016-02-02
// Description: This file contains the CSR SPMV Kokkos function. It is used
//              in the CoPilotOutput.cpp file.
//              It is a templated function, so it is included in the header
//              file.
//
//              This is a modified version of the KokkosKernels SPMV function
//              (

=======

// CSR SPMV Kokkos function
// Date: 10/04/2019

=======

// CSR SPMV Kokkos function
// Date: 12/2019

=======

// CSR SPMV Kokkos function
//
// Date: 12/15/2019
### end of output
// Prompt: CSR SPMV SYCL
### Beignning of output
Synthesizing 2/10 solutions

=======

// Prompt: CSR SPMV SYCL Kernel
// Comment: 
// Options:
//  --no-inline
//  --no-struct-return
//  --use-emulated-local-memory
//  --no-serial-memop
//  --no-

=======

// Prompt: CSR SPMV SYCL Kernel
// Comment: This file contains the kernel for performing CSR SPMV using SYCL
// devices
// Date: 03/09/2020

### end of output
// Prompt: CSR SPMV SYCL function
Synthesizing 4/10 solutions

=======

// Prompt: CSR SpMV SYCL function
// Created: 2021-04-23 15:23:18
// Modified: 2021-04-23 15:23:18
//

#include <CL/sycl.hpp>
#include <iostream>
#include <math.h>

#include "csr_spmv.hpp"
#include "sycl.hpp"

using namespace cl::sycl;

void csr_spmv(int *ptr, int *indices, float *data, float *x, float *y, int n) {

=======

// Prompt: CSR SpMV SYCL function
// Input:
//   - csr_matrix: CSR matrix
//   - x: input vector
//   - y: output vector
//   - num_rows: number of rows
//   - num_nonzeros: number of nonzeros
//   - num_nonzeros_per_row: number of nonzeros per row
//   - num_vectors: number of vectors
//   - num_groups: number of groups
//   - num_work_items_per_group: number of work items per group
//   - num_work_items: number of work items
// Output:
//   - y: output vector
//   - csr_matrix: CSR matrix
//   - x: input vector
//   - num_rows: number of rows
//   - num_nonzeros: number of nonzeros
//   - num_nonzeros_per_row: number of nonzeros per row
//   - num_vectors: number of vectors
//   - num_groups: number of groups
//   - num_work_items_per_group: number of work items per group
//   - num_work_items: number of work items
// Settings:
//   - num_groups: 1
//   - num_work_items_per_group: 1
//   - num_work_items: 1
//   - num_rows: 1
//   - num_nonzeros_per_row: 1
//   - num_vectors: 1
//   - num_nonzeros: 1
//   - x: [1.0]
//   - y: [0.0]
//   - csr_

=======

// Prompt: CSR SpMV SYCL function
// Input: csr_matrix, x, y
// Output: y
// Dependencies: csr_spmv.h

=======

// Prompt: CSR SpMV SYCL function
// Input: A, x, y
// Output: y
// Condition: n = A.rows == x.rows == y.rows
### End of Output
// Prompt: CSR SpMV Thrust
### Beginning of Output
Synthesizing 2/10 solutions

=======

// Prompt: CSR SpMV Thrust
// Input: csr_data, csr_indices, csr_ptr, x, y
// Output: y
// Stdout: 
// Stderr: 
// S

=======

// Prompt: CSR SpMV Thrust
// Input: csr, x
// Output: y
// Benchmark: 1.37 GFLOPS
// Description: CSR SpMV using thrust
// Date: 2012.01.03
### End of Output
// Prompt: CSR SPMV Thrust function
### Beignning of output
Synthesizing 6/10 solutions

=======

// Prompt: CSR SPMV Thrust Function
// Input: none
// Output: none

=======

// Prompt: CSR SPMV Thrust Function
// Input: A (CSR), x, y
// Output: y
// Benchmark: SPMV/CoPilotOutput/csr_spmv.cpp
//---------------------------------------------------------

// Thrust includes
#include <thrust/device_ptr.h>
#include <thrust/scan.h>
#include <thrust/transform.h>
#include <thrust/functional.h>
#include <thrust/copy.h>
#include <thrust/iterator/zip_iterator.h>
#include <thrust/iterator/permutation_iterator.h>

// CoPilot includes
#include <copilot/device.hpp>
#include <copilot/executor.hpp>
#include <copilot/data_types.hpp>
#include <copilot/traits.hpp>
#include <copilot/operations.hpp>
#include <copilot/memory.hpp>
#include <copilot/algorithm.hpp>
#include <copilot/transform.hpp>
#include <copilot/scan.hpp>

// Standard includes
#include <iostream>
#include <iomanip>
#include <cstdlib>
#include <cassert>
#include <cmath>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>

// CUDA includes
#include <cuda.h>
#include <cuda_runtime.h>
#include <cuda_runtime_api.h>

// CSR SPMV Thrust Function
// --------

=======

// Prompt: CSR SPMV Thrust Function
// Created: 2012-04-18 16:52:51
// Modified: 2012-04-18 16:52:51
// ******************************************************

#include "csr_spmv.h"

void csr_spmv(int num_rows, int num_cols, int Ap[], int Aj[], float Ax[], float x[], float y[]) {

=======

// Prompt: CSR SPMV Thrust Function
// Input: A, x
// Output: y
// Benchmark:
// Options:
// Devices: CPE
// Created: 2011-09-07
// Modified: 2011-09-07

#include <iostream>
#include <fstream>
#include <string>
#include <cstdlib>

#include <thrust/device_vector.h>
#include <thrust/host_vector.h>
#include <thrust/copy.h>
#include <thrust/scan.h>
#include <thrust/iterator/constant_iterator.h>
#include <thrust/iterator/counting_iterator.h>
#include <thrust/iterator/transform_iterator.h>
#include <thrust/functional.h>

#include <cusp/csr_matrix.h>
#include <cusp/monitor.h>
#include <cusp/detail/timer.h>

#include <cusp/blas.h>
#include <cusp/multiply.h>
#include <cusp/array1d.h>

#include "cusp/detail/format_utils.h"

#include <cusp/hyb_matrix.h>
#include <cusp/convert.h>

#include "csr_spmv.h"

#include "cusp/detail/format_utils.h"

#include <cusp/krylov/cg.h>
#include <cusp/krylov/bicgstab.h>
#include <cusp/krylov/gmres.h>
#include <cusp/krylov/cg.h>
#include <cusp/krylov/bicgstab.h>
#include <cusp/krylov/gmres.h>
#include <cusp/krylov/arnoldi.h>
#include <cusp/krylov/arnoldi.h>
#include <cusp/krylov/arnoldi.h>
#include <cusp/krylov/arnoldi.h>

#include <cusp/precond/aggregation/smoothed_aggregation.h>
#include <cusp/precond/diagonal.h>
#include <cusp/pre

=======

// Prompt: CSR SPMV Thrust Function
// Input: CSR Matrix, Vector, and Vector Length
// Output: Vector

=======

// Prompt: CSR SPMV Thrust Function
// Input: CSR Matrix, Vector
// Output: Vector
// Benchmark: 0.005s
// Description: This is a CSR SPMV function. It uses Thrust to perform the
//              multiplication. It is very fast, but it is not very memory
//              efficient. It is also not very good for the GPU. It is included
//              for comparison purposes.
//
=== End of Output
